Homework 07
===========
1. In node_create I allocated enough memory for the sizeof(struct node). I did this by using malloc(sizeof(struct node)). This allocates enough memory for a single node which is what we want. I also allocated memory for the string which was to be placed in the node. This was done by using strdup which alloocates enough memory given a string. In node_delete I first deallocated the string of the node with free(n->string) and then I deallocated the entire node with free(n). If the recursive flag was set to true, I traveresed through eveyr connected node in the list. I did this by setting a pointer to the next element of the current node until that element was NULL. I then freed the string and node of every node within the while loop. 

2. In list_create I allocated enough memory for a single list struct. I did this by using malloc(sizeof(struct list)). In list_delete I call the node_delete function passing through the head of the list and 'true'. THe true makes sure that every connected node is deallocated. After that function runs, free(l) is called to deallocate the list itself.

3. THe list_qsort function starts by putting the list into an array by calling list_to_array(l). This function allocates enough memory to store the entire list by multiplying l->size by sizeof(struct node * ) and calling malloc on the product. Once the memory is allocated, the l->head is stored into the first element of the array. Then a for loop is called to poulate the rest of the array with the node pointers from the original list. After the array is populated in list_qsort by calling list_to_array(l), qsort is called on the array. l->size, sizeof(struct node * ) and f were all passed into the qsort function so that the array could be appropriately sorted. The list is then repopulated using the newly sorted array. After the list is filled up, the array is deallocated. 

averag time complexity: O(nlog(n))
worse case time: O(n^2)
space complexity: O(1)


4. list_reverse begins by setting the l->tail equal to l->head. Then l->head is set equal to the output of the fuction reverse(l->head, NULL). This function recursively revereses nodes by taking in a current node and a previous node. Within the function if the current->next value is null then that value is set to the prev node which was passed to the function. Then this current node (with its next value set to prev) is returned. After that first if statement, a ptr node struct is created and set equal to curr->next. THen curr->next is set to the prev node passed in. Finally, curr is set to reverse(ptr, curr) so that the function is called recursively until completion (curr->next is equal to NULL). 

average and worse case time: O(n)
space: O(1)

5. The list_msort works initially by setting the lists head pointer equal to the output of msort(l->head, f). msort then begins by return the head (node passed in) only if that head pointer is set to NULL or if head-> next is set to NULL. If nother of those conditionals pass, then msort continues by creating a left and right node struct pointer (both set equal to NULL). Then the function split is called on head, the location of the left pointer, and the location of the right pointer. Split takes these node pointers and splits the list. This happens by setting the left pointer equal to the head of the node passed into split, and setting the right pointer equal to the middle point of singly linked list. SPlit is implemented by using a fast, slow, and tail pointer. The slow pointer was used to give the right pointer a starting point, fast was used to so that slow was located in the middle of the linked list, and tail was used as an ending point for the left sublist. THis happened by setting tail->next equal to NULL after tail is at the loaction before slow. Noww, back to the msort function. After the origianl list was split into two parts. The left part is set equal to msort(left, f) and the right side was set equal to msort(right, f). THis recursive call essentially keeps splitting the list until there ar individual nodes. These nodes are then passed into the merge function. THe merge function uses if/else if/ else statements to populating a node pointer called complete. A left and right helper pointer is also used to help this process. These are initially set equal to right and left (inputs of function. If either of the helpers are NULL then they are then se equal to helpR->next or helpL->next. complete->next is set equal to right (or left), right (or left) is set to helpR (or helpL) and complete is set to complete->next. In each of these cases a counter is also increased by 1. If niether are Null, then else if (f(&helpL, &helpR) <= 0) is called. If this is true then another if/else is used. This if is dependent on whther the counter == 0. If it does then complete is set to helpL, head is set to complete, helpL is set to helpL->next and left is set to helpL. IF the counter is not 1, then helpL is set to helpL->next, complete->next is set to left, left is set to helpL and complete to complete->next. After this if/else statements, the counter is then increased by one. Finally, an else is used from if original if/else if/ else structure. This leads into an if/else. Similariry, if the counter is 0 then complete is set to helpR, head is set to complete, helpR is set to helpR->next and right is set to helpR. If the counter is not 0, then complete->next is set to right, rigth is set to helpR, complete is set to complete->next and helpR is set to helpR->next. Finally, the counter is increased after this. Essentially these if/else statements use comparitive logic to place the split linked lists into a single list based on their values. This makes sure each split list is compined and merged in the right order.

average and worse case time: O(nlog(n))
space: O(log(n))

THe space complexity is that way since msort is called recursively 

1. Both time and space increas as the number of items increase for both sorting methods. However, once the numbers become large (>1000) merge sort takes longer than quick sort. As for space, when the items increase the space is always larger for quick sort. This is not what I expected due to the complexitities found in activity 1 (Merge had a the same average time complexity but quick sort had larger worse case time complexity) Also, merge sort as a larger space complexity, but after the experiment, quick sort took up more space

2. Real world performance does not always reflect the theoretical complexities derived. I can credit this to the fact that theoretical complexitites come from only the code and are an estimate on how something behaves. However, hardware differs for computers, so it makes it difficult to accurately esimate both time and space complexities
